<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hybrid MPK+ZST Artifact Consumer</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script>
      (function () {
        const saved = localStorage.getItem("theme");
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        const theme = saved || (prefersDark ? "dark" : "light");
        document.documentElement.setAttribute("data-theme", theme);

        const viewModeSaved = localStorage.getItem("viewMode");
        const viewModeValue = viewModeSaved || "comfort";
        document.documentElement.setAttribute("data-viewmode", viewModeValue);
      })();
    </script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        line-height: 1.6;
        margin: 0;
        background-color: #f8f9fa;
        color: #212529;
      }
      .container {
        max-width: var(--vm-container-maxwidth);
        margin: 2rem auto;
        padding: var(--vm-container-padding);
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .grid-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        width: 100%;
        gap: 0 1em;
        margin-top: 0.5em;

        grid-template-areas:
          "a b"
          "c b"
          ". b"
          ". b";

        > div {
          width: 100%;
          overflow: hidden;
        }

        > div#detailed-byte-breakdown {
          grid-area: a;
        }
        > div#static-assets-section {
          grid-area: b;
        }
        > div#stream-info-section {
          grid-area: c;
        }
      }

      h1 {
        line-height: 1.05em;
      }

      h1,
      h2,
      h3 {
        color: #343a40;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: var(--vm-heading-padding-bottom);
        margin-top: var(--vm-heading-margin-top);
        margin-bottom: var(--vm-heading-margin-bottom);
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
        position: sticky;
        top: 0em;
        padding: 0.5em 0.5em;
        background-color: var(--container-bg);
        z-index: 1000;
      }
      label {
        font-weight: bold;
      }
      select,
      button {
        padding: 0.5rem 1rem;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 1rem;
        cursor: pointer;
      }
      button {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #0056b3;
      }
      button[disabled] {
        opacity: 0.5;
      }
      #status {
        font-style: italic;
        color: #6c757d;
        margin-bottom: 1rem;
        white-space: pre-line;
        padding: 1em;
        background-color: #e9ecef;
        border-radius: 4px;
      }
      pre {
        background-color: #e9ecef;
        padding: 1rem;
        border-radius: 4px;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 400px;
        overflow-y: auto;
        margin: var(--vm-pre-margin);
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 1rem;
      }
      th,
      td {
        border: 1px solid #dee2e6;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f1f3f5;
      }
      .hidden {
        display: none;
      }
      #log-bins-button {
        font-size: 0.75em;
        padding: 0.25em;
        background: gray;
      }
      .viz-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }
      #viz-buttons-container button {
        background-color: #28a745;
        border-color: #28a745;
        margin-right: 10px;
        margin-bottom: 10px;
      }
      #viz-buttons-container button:hover {
        background-color: #218838;
      }
      @keyframes bounceArrow {
        0% {
          transform: translateY(50%);
        }
        50% {
          transform: translateY(30%);
        }
        100% {
          transform: translateY(50%);
        }
      }
        @keyframes glowPulse {
        0% {
            filter: brightness(1)
                    drop-shadow(0 0 0px #44f9ff80)
                    drop-shadow(0 0 10px #44f9ff80);
            /* Slightly transparent blue glow */
        }
        100% {
            filter: brightness(2.5)
                    drop-shadow(0 0 6px #44f9ff)
                    drop-shadow(0 0 35px #44f9ff);
            /* More intense glow */
        }
        }
      .accordion {
        cursor: pointer;
        padding: 0.5rem 0.5rem;
        margin: 0.5rem 0;
        background-color: var(--container-bg);
        border: none;
        border-radius: 5px;
        text-align: left;
        outline: none;
        font-size: 1.1rem;
        transition: background-color 0.3s;
        width: 100%;
        position: relative;

        h3 {
          margin: 0;
          border: none;
          padding: 0;
        }

        ::after {
          content: "▼";
          display: inline;
          margin-left: 0.25rem;
          font-size: 0.75rem;
          transition: transform 0.3s;
          position: absolute;
          bottom: 50%;
          transform: translateY(50%);
        }

        border-left: 3px solid var(--button-bg);
      }
      .accordion.animate *::after {
        animation: bounceArrow 1s ease infinite alternate, glowPulse 0.5s infinite alternate;
        will-change: filter, transform;
      }
      .accordion:hover {
        background-color: var(--control-hover);
      }
      .accordion.active {
        background-color: var(--control-bg);
        color: var(--button-text);

        ::after {
          content: "▲";
        }
      }
      .panel {
        padding: 0 1rem;
        max-height: 0;
        transition: max-height 0.3s ease-out;
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        border-radius: 0 0 5px 5px;
      }
      .panel--preview {
        max-height: calc(4 * 1.6rem);
      }
      .panel--preview-8 {
        max-height: calc(8 * 1.6rem);
      }
      .fnt-sml {
        font-size: 0.85rem;
        padding: 0.5rem;
      }
      * {
        scrollbar-width: medium;
        scrollbar-color: var(--scroll-thumb) var(--scroll-track);
      }

      /* For WebKit browsers (Chrome, Edge, Safari) */
      *::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      *::-webkit-scrollbar-thumb {
        background-color: var(--scroll-thumb);
        border-radius: 4px;
      }
      *::-webkit-scrollbar-track {
        background-color: var(--scroll-track);
      }
      .false {
        border: none;
      }
      .mw-64em.mw-64em {
        max-width: 64em;
      }
      .m-ha {
        margin-left: auto;
        margin-right: auto;
      }
      .oh {
        overflow: hidden;
      }
    </style>

    <style>
      /* User Settings */
      /*  1. View Mode */
      /*  2. Dark Mode */

      /* 1. View Mode */
      [data-viewmode="comfort"] {
        --vm-container-padding: 2rem;
        --vm-container-maxwidth: 64em;
        --vm-heading-padding-bottom: 0.5rem;
        --vm-heading-margin-top: 2rem;
        --vm-heading-margin-bottom: 0.8rem;
        --vm-pre-margin: 1em;
      }
      [data-viewmode="detailed"] {
        --vm-container-padding: 1.5rem;
        --vm-container-maxwidth: 96em;
        --vm-heading-padding-bottom: 0.1rem;
        --vm-heading-margin-top: 0.2rem;
        --vm-heading-margin-bottom: 0.2rem;
        --vm-pre-margin: 0.25em;
      }

      /* 2. Dark Mode */
      /* 1) Define all your colors as CSS variables */
      :root {
        --bg: #f8f9fa;
        --text: #212529;
        --container-bg: #ffffff;
        --header: #343a40;
        --border: #dee2e6;
        --control-bg: #e9ecef;
        --button-bg: #007bff;
        --button-text: white;
        --button-hover: #0056b3;
        --scroll-thumb: #aaa;
        --scroll-track: #eee;
      }
      /* 2) Override your existing rules to use those vars */
      body {
        background-color: var(--bg);
        color: var(--text);
      }
      .container {
        background-color: var(--container-bg);
      }
      h1,
      h2,
      h3 {
        color: var(--header);
        border-bottom-color: var(--border);
      }
      #status,
      pre,
      th {
        background-color: var(--control-bg);
      }
      select,
      button {
        background-color: var(--container-bg);
        border-color: var(--border);
        color: var(--text);
      }
      button {
        background-color: var(--button-bg);
        color: var(--button-text);
      }
      button:hover {
        background-color: var(--button-hover);
      }
      /* 3) Define your dark palette under a [data-theme="dark"] selector */
      [data-theme="dark"] {
        --bg: #121212;
        --text: #e0e0e0;
        --container-bg: #1e1e1e;
        --header: #fafafa;
        --border: #333;
        --control-bg: #2a2a2a;
        --control-hover: #4b4b4b;
        --button-bg: #3880ff;
        --button-text: white;
        --button-hover: #1c54b2;
        --scroll-thumb: #666;
        --scroll-track: #333;
      }
    </style>
  </head>
  <body>
    <div style="position: fixed; top: 1rem; right: 1rem; z-index: 500">
      <button id="view-mode-toggle" class="fnt-sml">Detailed</button>
      <button id="toggle-all-button" class="fnt-sml">
        Expand All Accordions
      </button>
      <button id="theme-toggle" class="fnt-sml">Dark Mode</button>
    </div>
    <div class="container">
      <h1>Hybrid MPK+ZST Artifact Viewer</h1>
      <div class="controls mw-64em m-ha">
        <label for="stream-select">Select Data Stream:</label>
        <select id="stream-select" disabled></select>
        <button id="load-button" disabled>Load and Parse Stream</button>
        <button id="log-bins-button" disabled>Log Actual Bin Sizes</button>
      </div>
      <div id="status" class="mw-64em m-ha">Loading... Please wait.</div>
      <div class="mw-64em m-ha">
        <h2>Bundle Byte Size Breakdown</h2>
        <div
          id="byte-size-bar-container"
          style="
            border: 1px solid #ccc;
            height: 30px;
            display: flex;
            cursor: default;
          "
        ></div>
      </div>
      <div
        id="byte-size-bar-tooltip"
        style="
          position: absolute;
          background: rgba(0, 0, 0, 0.75);
          color: white;
          padding: 5px 8px;
          border-radius: 4px;
          font-size: 0.85rem;
          pointer-events: none;
          opacity: 0;
          transition: opacity 0.2s;
          z-index: 1000;
        "
      ></div>
      <div class="grid-container">
        <div id="detailed-byte-breakdown">
          <h2 class="false">&nbsp;</h2>
          <button class="accordion">
            <h3>Detailed Unpacked Size Analysis</h3>
          </button>
          <pre id="detailed-breakdown-output" class="panel panel--preview">
Calculating...</pre
          >
        </div>
        <div id="static-assets-section" class="hidden">
          <h2>Static Assets</h2>
          <div id="game-meta-container" class="hidden">
            <button class="accordion"><h3>Game Meta</h3></button>
            <pre id="game-meta-output" class="panel panel--preview"></pre>
          </div>
          <div id="defs-map-container" class="hidden">
            <button class="accordion"><h3>Definitions Map</h3></button>
            <pre id="defs-map-output" class="panel panel--preview"></pre>
          </div>
        </div>
        <div id="stream-info-section" class="hidden">
          <button class="accordion"><h3>Selected Stream Schema</h3></button>
          <pre id="stream-schema-output" class="panel panel--preview"></pre>
        </div>
      </div>
    <div>

    <button class="accordion"><h2>Parsed Data</h3></button>
      <button id="show-unit-names-button" disabled>Show Unit Names</button>
      <div id="parsed-data-output" class="panel panel--preview-8 oh"><em>No data loaded yet.</em></div>
      <div
        id="visualization-sandbox"
        class="hidden"
        style="width: 100%; display: flex; flex-direction: column"
      >
        <div class="container">
          <!-- Add a nested container for the header and controls -->
          <h2>Visualization Sandbox</h2>
          <p>
            The following visualizations are possible with the currently loaded
            stream. Click one to generate.
          </p>
          <div id="viz-buttons-container"></div>
          <div id="sandbox-controls"></div>
        </div>
        <!-- The chart div itself remains outside the nested container to allow it to be full width -->
        <div
          id="sandbox-chart"
          style="display: flex; width: 100%; height: 600px; margin-top: 20px"
        ></div>
      </div>
    </div>
      <h2>Full Artifact Schema</h2>
      <pre id="full-schema-output">Loading...</pre>
    </div>

    <script type="module">
      import { Zstd } from "https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2.23.0/dist/index.js";
      import { decode } from "https://esm.sh/@msgpack/msgpack@3.1.2/es2022/msgpack.mjs";

      const NUM_ROWS_TO_SHOW = 50;
      let sandboxChartInstance = null;
      let lastColumns = null;
      let VIZ_REGISTRY;

      document.addEventListener("DOMContentLoaded", async () => {
        const zstd = await Zstd.load();
        const streamSelect = document.getElementById("stream-select");
        const loadButton = document.getElementById("load-button");
        const statusDiv = document.getElementById("status");
        const fullSchemaOutput = document.getElementById("full-schema-output");
        const streamInfoSection = document.getElementById(
          "stream-info-section"
        );
        const streamSchemaOutput = document.getElementById(
          "stream-schema-output"
        );
        const parsedDataOutput = document.getElementById("parsed-data-output");

        const detailedBreakdownOutput = document.getElementById(
          "detailed-breakdown-output"
        );
        const barContainer = document.getElementById("byte-size-bar-container");
        const tooltip = document.getElementById("byte-size-bar-tooltip");

        const staticAssetsSection = document.getElementById(
          "static-assets-section"
        );
        const gameMetaContainer = document.getElementById(
          "game-meta-container"
        );
        const gameMetaOutput = document.getElementById("game-meta-output");
        const defsMapContainer = document.getElementById("defs-map-container");
        const defsMapOutput = document.getElementById("defs-map-output");

        const REPLAY_ID = "test_replay_id";
        const ARTIFACT_PATH = `./${REPLAY_ID}.mpk.zst`;

        VIZ_REGISTRY = [
          {
            name: "Flexible Chart Builder",
            check: (columns) => {
              // This check remains the same
              return (
                columns.some(
                  (c) => c.dtype.includes("Int") || c.dtype.includes("Float")
                ) && columns.length >= 2
              );
            },
            render: (data, chartInstance, controlsContainer) => {
              const allDims = lastColumns.map((c) => c.name);
              const numericMetrics = lastColumns
                .filter(
                  (c) => c.dtype.includes("Int") || c.dtype.includes("Float")
                )
                .map((c) => c.name);
              const controlsHtml = `
              <div class="viz-controls">
                  <div><label>Dimension (X-Axis):</label><br/><select id="ctrl-dim">${allDims
                    .map((c) => `<option value="${c}">${c}</option>`)
                    .join("")}</select></div>
                  <div><label>Metric (Y-Axis):</label><br/><select id="ctrl-metric">${numericMetrics
                    .map((c) => `<option value="${c}">${c}</option>`)
                    .join("")}</select></div>
                  <div><label>Group By (Optional):</label><br/><select id="ctrl-group"><option value="">-- None --</option>${allDims
                    .map((c) => `<option value="${c}">${c}</option>`)
                    .join("")}</select></div>
                  <button id="ctrl-render">Render</button>
              </div>`;

              controlsContainer.innerHTML = controlsHtml; // Render controls

              document.getElementById("ctrl-render").onclick = () => {
                const dimCol = document.getElementById("ctrl-dim").value;
                const metricCol = document.getElementById("ctrl-metric").value;
                const groupCol = document.getElementById("ctrl-group").value;

                // --- ROBUST AGGREGATION LOGIC (THE FIX) ---

                const aggregatedData = new Map(); // Key: dimension value, Value: { group1: metric, group2: metric }
                const allGroups = new Set();

                data.forEach((row) => {
                  const dimValue = row[dimCol];
                  const metricValue = Number(row[metricCol] || 0);
                  const groupValue = groupCol ? row[groupCol] : "default";

                  allGroups.add(groupValue);

                  if (!aggregatedData.has(dimValue)) {
                    aggregatedData.set(dimValue, {});
                  }
                  const dimEntry = aggregatedData.get(dimValue);
                  dimEntry[groupValue] =
                    (dimEntry[groupValue] || 0) + metricValue;
                });

                // Prepare sorted dimensions (x-axis) and groups (series)
                const sortedDimensions = [...aggregatedData.keys()].sort(
                  (a, b) => {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                  }
                );
                const sortedGroups = [...allGroups].sort();

                const isTimeSeries = lastColumns
                  .find((c) => c.name === dimCol)
                  .dtype.includes("Int");

                // Build the series array, feeding each series its own specific data.
                const series = sortedGroups.map((group) => {
                  return {
                    name: String(group),
                    type: isTimeSeries ? "line" : "bar",
                    stack: isTimeSeries || !groupCol ? null : "total",
                    smooth: true,
                    data: sortedDimensions.map((dim) => {
                      const value = aggregatedData.get(dim)?.[group] || null; // Use null for missing data points
                      return value;
                    }),
                  };
                });

                chartInstance.setOption(
                  {
                    // NO LONGER using `dataset`. We provide data directly to the series.
                    tooltip: { trigger: "axis" },
                    legend: { type: "scroll", show: !!groupCol },
                    xAxis: {
                      type: "category",
                      name: dimCol,
                      data: sortedDimensions.map(String),
                    },
                    yAxis: { type: "value", name: metricCol },
                    series: series,
                  },
                  true
                );
              };

              // Auto-click the render button for a default view
              document.getElementById("ctrl-render").click();
            },
          },
            {
                name: "Sankey Diagram (Interactive)",
                check: (columns) => {
                    const colNames = columns.map((c) => c.name);
                    return [
                        "team_id",
                        "unit_def_id",
                        "total_metal_produced_in_bin",
                        "total_metal_consumed_in_bin",
                    ].every((c) => colNames.includes(c));
                },
                render: async (data, chartInstance, controlsContainer) => {
                    
                    // This helper function will be used after the main data processing is complete.
                    // It simplifies a large Sankey graph by grouping insignificant nodes.
                    const aggregateSankeyData = (fullData, topN) => {
                        const { links, nodeFlows } = fullData;

                        // 1. Identify the most significant nodes by their total flow.
                        const sortedNodes = Array.from(nodeFlows.entries())
                            .sort((a, b) => b[1] - a[1]);
                        
                        const significantNodes = new Set(sortedNodes.slice(0, topN).map(entry => entry[0]));

                        // 2. Create the simplified graph structure.
                        const finalLinks = new Map(); // Use a map to aggregate links between the same nodes.

                        const getFinalNodeName = (originalName) => {
                            // Always keep teams as individual nodes.
                            if (originalName.startsWith("Team")) {
                                return originalName;
                            }
                            // Check if the node is in our "Top N" list.
                            if (significantNodes.has(originalName)) {
                                return originalName;
                            }
                            // Otherwise, group it into a generic "Other" category.
                            if (originalName.startsWith("Producer:")) return "Other Producers";
                            if (originalName.startsWith("Consumer:")) return "Other Consumers";
                            return "Other";
                        };

                        // 3. Process all original links and aggregate them into the new, simplified structure.
                        for (const link of links) {
                            const source = getFinalNodeName(link.source);
                            const target = getFinalNodeName(link.target);

                            // Avoid self-loops (e.g., from "Other Producers" to "Other Producers").
                            if (source === target) continue;

                            const linkKey = `${source}|${target}`;
                            const existingLink = finalLinks.get(linkKey) || { source, target, value: 0 };
                            existingLink.value += link.value;
                            finalLinks.set(linkKey, existingLink);
                        }
                        
                        // 4. Collect all unique nodes that appear in our final, aggregated links.
                        const finalNodeSet = new Set();
                        finalLinks.forEach(link => {
                            finalNodeSet.add(link.source);
                            finalNodeSet.add(link.target);
                        });

                        return {
                            nodes: Array.from(finalNodeSet).map(name => ({ name })),
                            links: Array.from(finalLinks.values()),
                        };
                    };

                    // --- STAGE 1: Calculate the full data model (non-blocking) ---
                    chartInstance.showLoading({
                        text: 'Calculating full data model...',
                        color: '#3880ff',
                        textColor: '#e0e0e0',
                        maskColor: 'rgba(30, 30, 30, 0.3)',
                    });
                    
                    const sankeyChunkProcessor = (chunk, accumulator) => {
                        chunk.forEach((row) => {
                            const teamName = `Team ${row.team_id}`;
                            const producerName = `Producer: Unit ${row.unit_def_id}`;
                            const consumerName = `Consumer: Unit ${row.unit_def_id}`;

                            const produced = Number(row.total_metal_produced_in_bin);
                            const consumed = Number(row.total_metal_consumed_in_bin);

                            const updateTotalFlow = (node, value) => {
                                accumulator.nodeFlows.set(node, (accumulator.nodeFlows.get(node) || 0) + value);
                            };

                            if (produced > 0) {
                                accumulator.links.push({ source: producerName, target: teamName, value: produced });
                                updateTotalFlow(producerName, produced);
                                updateTotalFlow(teamName, produced);
                            }
                            if (consumed > 0) {
                                accumulator.links.push({ source: teamName, target: consumerName, value: consumed });
                                updateTotalFlow(teamName, consumed);
                                updateTotalFlow(consumerName, consumed);
                            }
                        });
                        return accumulator;
                    };
                    
                    const initialState = { links: [], nodeFlows: new Map() };
                    const fullResult = await processDataInChunksAsync(data, sankeyChunkProcessor, initialState);
                    
                    chartInstance.hideLoading();

                    // --- STAGE 2: Setup interactive controls ---
                    controlsContainer.innerHTML = `
                        <div style="padding: 10px 0; display: flex; align-items: center; gap: 10px;">
                            <label for="sankey-detail-slider">Detail Level (Top N Nodes):</label>
                            <input type="range" id="sankey-detail-slider" min="10" max="200" value="50" step="10" style="vertical-align: middle; flex-grow: 1;">
                            <span id="sankey-detail-label" style="font-weight: bold; font-family: monospace; display: inline-block; width: 3em; text-align: right;">50</span>
                        </div>
                    `;
                    
                    const slider = document.getElementById('sankey-detail-slider');
                    const label = document.getElementById('sankey-detail-label');

                    // --- STAGE 3: The re-rendering function that uses the slider's value ---
                    const updateChart = () => {
                        const topN = parseInt(slider.value, 10);
                        label.textContent = topN;
                        
                        // This aggregation is now a very fast, synchronous operation.
                        const simplifiedGraph = aggregateSankeyData(fullResult, topN);

                        chartInstance.setOption({
                            tooltip: {
                                trigger: "item",
                                triggerOn: "mousemove"
                            },
                            series: [{
                                type: "sankey",
                                data: simplifiedGraph.nodes,
                                links: simplifiedGraph.links,
                                emphasis: {
                                    focus: "adjacency"
                                },
                                lineStyle: {
                                    color: "gradient",
                                    curveness: 0.5
                                },
                                levels: [{ // Add some styling to make "Other" nodes less prominent
                                    depth: 0,
                                    itemStyle: { color: '#3880ff' }, // Emphasize team nodes
                                    lineStyle: { color: 'source', opacity: 0.6 }
                                }],
                            }],
                        }, true);
                    };

                    // --- STAGE 4: Attach event listener and trigger initial render ---
                    slider.addEventListener('input', updateChart);
                    updateChart(); // Initial render with default settings
                },
            }
        ];

        let artifact = null;
        let decodedDefsMap = null;
        let lastParsedData = null;

        try {
          statusDiv.textContent = `Fetching artifact: ${ARTIFACT_PATH}...`;
          const response = await fetch(ARTIFACT_PATH);
          if (!response.ok)
            throw new Error(
              `HTTP error! status: ${response.status}. Is your local server running?`
            );

          const compressedBuffer = await response.arrayBuffer();
          statusDiv.textContent = `Decompressing ${compressedBuffer.byteLength} bytes...`;
          const packedBytes = zstd.decompress(new Uint8Array(compressedBuffer));

          statusDiv.textContent = `Decompressed. Parsing ${packedBytes.byteLength} MessagePack bytes...`;
          artifact = decode(packedBytes);
          initLogBinsButton(artifact);

          //   for (const [key, blob] of Object.entries(artifact.data)) {
          //     if (blob instanceof Uint8Array) {
          //       console.log(`Blob '${key}': ${blob.byteLength} bytes`);
          //     } else {
          //       console.warn(
          //         `Blob '${key}' is not Uint8Array, type: ${typeof blob}`
          //       );
          //     }
          //   }

          const schema = artifact.schema;
          fullSchemaOutput.textContent = JSON.stringify(
            schema,
            jsonBigIntReplacer,
            2
          );

          displayStaticAssets(artifact);

          renderByteSizeBar(
            artifact,
            packedBytes.byteLength,
            compressedBuffer.byteLength
          );

          const streamNames = Object.keys(schema.streams);
          if (streamNames.length === 0)
            throw new Error(
              "Artifact parsed, but the 'streams' object is empty."
            );

          streamSelect.innerHTML = "";
          streamNames.forEach((name) =>
            streamSelect.appendChild(new Option(name, name))
          );

          updateStreamSchemaDisplay();
          streamSelect.addEventListener("change", updateStreamSchemaDisplay);
          loadButton.addEventListener("click", parseSelectedStream);

          streamSelect.disabled = false;
          loadButton.disabled = false;
          statusDiv.textContent = `Hybrid artifact loaded from ${ARTIFACT_PATH}. Select a stream and click "Load and Parse Stream".`;
        } catch (error) {
          statusDiv.textContent = `Error loading artifact: ${error.message}\n\nMake sure you have run the Python script to generate the '${REPLAY_ID}.mpk.zst' file and are serving this page from a local web server (e.g., 'python -m http.server').`;
          console.error("Artifact load error:", error);
          return;
        }

        function updateStreamSchemaDisplay() {
          const selectedStreamName = streamSelect.value;
          if (artifact && artifact.schema.streams[selectedStreamName]) {
            streamSchemaOutput.textContent = JSON.stringify(
              artifact.schema.streams[selectedStreamName],
              jsonBigIntReplacer,
              2
            );
            streamInfoSection.classList.remove("hidden");
          } else {
            streamInfoSection.classList.add("hidden");
          }
        }

        function parseSelectedStream() {
          const selectedStreamName = streamSelect.value;
          if (!selectedStreamName) return;

          parsedDataOutput.innerHTML = "<em>Parsing...</em>";
          statusDiv.textContent = `Parsing stream: ${selectedStreamName}...`;

          try {
            const streamInfo = artifact.schema.streams[selectedStreamName];
            if (!streamInfo)
              throw new Error(
                `Stream '${selectedStreamName}' not found in schema.`
              );

            let parsedData;
            if (streamInfo.layout === "row-major-mixed") {
              const dataBlob = artifact.data[streamInfo.data_key]["default"];
              if (!dataBlob)
                throw new Error(
                  `Data blob not found for key: ${streamInfo.data_key}`
                );
              // msgpack decodes binary data into Uint8Array. We need its underlying ArrayBuffer.
              const dataBuffer = dataBlob.buffer.slice(
                dataBlob.byteOffset,
                dataBlob.byteOffset + dataBlob.byteLength
              );
              parsedData = parseRowMajorBuffer(dataBuffer, streamInfo);
            } else {
              // Default to columnar
              //   parsedData = parseColumnarBuffer(artifact.data, streamInfo);
              console.log(artifact.data[selectedStreamName]);
              console.log(artifact.data, selectedStreamName);
              console.log(streamInfo);
              parsedData = parseColumnarBuffer(
                artifact.data[selectedStreamName],
                streamInfo
              );
              debugCheckForIncompleteColumns(parsedData, streamInfo.columns);
            }

            parsedDataOutput.innerHTML = renderTable(
              parsedData,
              streamInfo.columns
            );

            console.log(parsedData)

            lastParsedData = parsedData;
            lastColumns = streamInfo.columns;
            // Enable the button if applicable
            const showUnitBtn = document.getElementById(
              "show-unit-names-button"
            );
            if (
              lastParsedData &&
              lastColumns &&
              lastColumns.some((c) => c.name === "unit_def_id") &&
              decodedDefsMap
            ) {
              showUnitBtn.disabled = false;
            } else {
              showUnitBtn.disabled = true;
            }
            statusDiv.textContent = `Successfully parsed ${parsedData.length} rows from '${selectedStreamName}'.`;

            setupSandbox(streamInfo.columns, parsedData);
          } catch (error) {
            statusDiv.textContent = `Error processing stream: ${error.message}`;
            console.error("Processing error:", error);
          }
        }

        function displayStaticAssets(artifact) {
          const schema = artifact.schema;
          const data = artifact.data;

          if (!schema.static_assets || schema.static_assets.length === 0) {
            return; // No static assets to display
          }

          staticAssetsSection.classList.remove("hidden");

          // Handle game_meta.json
          if (schema.static_assets.includes("game_meta")) {
            const meta_blob = data.game_meta;
            if (meta_blob) {
              try {
                const meta_string = new TextDecoder().decode(meta_blob);
                const meta_json = JSON.parse(meta_string);
                gameMetaOutput.textContent = JSON.stringify(
                  meta_json,
                  jsonBigIntReplacer,
                  2
                );
                gameMetaContainer.classList.remove("hidden");
              } catch (e) {
                gameMetaOutput.textContent = `Error parsing game_meta: ${e.message}`;
              }
            }
          }

          // Handle defs_map
          if (schema.static_assets.includes("defs_map")) {
            const defs_blob = data.defs_map;
            if (defs_blob) {
              try {
                // The defs_map is a nested MessagePack object
                decodedDefsMap = decode(defs_blob);
                defsMapOutput.textContent = JSON.stringify(
                  decodedDefsMap,
                  jsonBigIntReplacer,
                  2
                );
                defsMapContainer.classList.remove("hidden");
              } catch (e) {
                defsMapOutput.textContent = `Error parsing defs_map: ${e.message}`;
              }
            }
          }
        }

        // --- CORE PARSING LOGIC ---

        function parseRowMajorBuffer(arrayBuffer, streamInfo) {
          const dataView = new DataView(arrayBuffer);
          const results = [];
          const { num_rows, row_byte_stride, columns } = streamInfo;

          for (let i = 0; i < num_rows; i++) {
            const rowStartOffset = i * row_byte_stride;
            const rowObject = {};
            let currentOffsetInRow = 0;

            for (const column of columns) {
              const [rawValue, bytesRead] = readValueFromView(
                dataView,
                rowStartOffset + currentOffsetInRow,
                column.dtype
              );
              let finalValue = rawValue;

              if (column.transform && column.transform.scale) {
                finalValue = Number(rawValue) * column.transform.scale;
              }

              rowObject[column.name] = finalValue;
              currentOffsetInRow += bytesRead;
            }
            results.push(rowObject);
          }
          return results;
        }

        function hexDump(buffer, length = 64) {
          const uint8 = new Uint8Array(buffer, 0, length);
          let hexStr = "";
          for (let i = 0; i < uint8.length; i++) {
            hexStr += uint8[i].toString(16).padStart(2, "0") + " ";
            if ((i + 1) % 16 === 0) hexStr += "\n";
          }
          return hexStr.trim();
        }

        function parseColumnarBuffer(dataBlobs, streamInfo) {
          const { num_rows, columns } = streamInfo;
          const rows = Array.from({ length: num_rows }, () => ({}));

          const memo = {};
          const getBlob = (key) => {
            if (!memo[key]) memo[key] = dataBlobs[key];
            if (!memo[key]) throw new Error(`Missing blob ${key}`);
            return memo[key];
          };

          // For fixed-width primitives, read via DataView
          function decodePrimitiveColumn(col) {
            const blob = getBlob(col.data_key);
            const view = new DataView(
              blob.buffer,
              blob.byteOffset,
              blob.byteLength
            );
            const dtype = col.dtype;
            const stride = getStride(dtype);

            if (stride === 0) {
              // Should not happen with your getStride
              console.error(
                `Column '${col.name}' has zero stride for dtype ${dtype}. Skipping population.`
              );
              for (let r = 0; r < num_rows; r++) rows[r][col.name] = undefined;
              return;
            }

            const actualElementsInBlob = Math.floor(view.byteLength / stride);
            console.warn(
              `Column '${col.name}' blob only contains ${actualElementsInBlob} rows (blob size: ${view.byteLength} bytes, stride: ${stride}), but schema num_rows = ${num_rows}.`
            );

            if (view.byteLength > 0 && view.byteLength % stride !== 0) {
              console.warn(
                `Column '${col.name}' data length ${view.byteLength} is not a multiple of stride ${stride} for dtype ${dtype}. Data for last element might be incomplete or missing.`
              );
            }

            // Iterate up to num_rows (from schema) but only read if data exists in blob
            for (let r = 0; r < num_rows; r++) {
              if (r < actualElementsInBlob) {
                const off = r * stride;
                // Double check read is within actual view bounds, though actualElementsInBlob should ensure this
                if (off + stride <= view.byteLength) {
                  rows[r][col.name] = readViewValue(view, off, dtype);
                } else {
                  // This case should ideally not be hit if actualElementsInBlob is correct
                  console.error(
                    `Internal error or miscalculation: Attempting to read beyond blob bounds for column '${col.name}', row ${r}.`
                  );
                  rows[r][col.name] = undefined;
                }
              } else {
                // Schema expects more rows than data exists for in this blob.
                // console.warn(`Column '${col.name}': Schema expects num_rows=${num_rows}, but blob only contains data for ${actualElementsInBlob} elements. Padding row ${r} with undefined.`);
                rows[r][col.name] = undefined;
              }
            }
          }

          // --- main column loop ---
          for (const col of columns) {
            // Fixed-width primitive
            if (col.data_key && !col.offsets_key) {
              decodePrimitiveColumn(col);
              continue;
            }
            // Variable-width Utf8 / List<primitive>
            if (col.offsets_key && col.data_key) {
              const offs = decodeOffsets(getBlob(col.offsets_key));
              const payload = getBlob(col.data_key); // This is a Uint8Array view on the full payload data
              const slices = sliceByOffsets(payload, offs); // Slices are Uint8Array views

              if (col.dtype === "Utf8" || col.dtype === "String") {
                slices.forEach((bytes, idx) => {
                  // 'bytes' is a Uint8Array, a slice of payload
                  rows[idx][col.name] = new TextDecoder().decode(bytes);
                });
              } else {
                // List<int/float/etc>
                const innerTypeMatch = col.dtype.match(/List\((.*)\)/);
                if (!innerTypeMatch || !innerTypeMatch[1]) {
                  console.error(
                    `Could not parse inner type for List in column '${col.name}', dtype: ${col.dtype}`
                  );
                  slices.forEach((_, idx) => (rows[idx][col.name] = []));
                  continue;
                }
                const innerType = innerTypeMatch[1];
                const stride = getStride(innerType);

                if (stride === 0) {
                  // Should not happen
                  console.error(
                    `List<${innerType}> for column '${col.name}' has zero stride. Assigning empty lists.`
                  );
                  slices.forEach((_, idx) => (rows[idx][col.name] = []));
                  continue;
                }

                slices.forEach((bytes, idx) => {
                  // 'bytes' is a Uint8Array representing one list's data
                  const arr = [];
                  const view = new DataView( // DataView specific to this list's byte slice
                    bytes.buffer,
                    bytes.byteOffset,
                    bytes.byteLength
                  );

                  const numElementsInListSlice = Math.floor(
                    bytes.byteLength / stride
                  );

                  if (bytes.byteLength > 0 && bytes.byteLength % stride !== 0) {
                    console.warn(
                      `List<${innerType}> slice for column '${col.name}', row ${idx} has byteLength ${bytes.byteLength} which is not a multiple of stride ${stride}. Last element(s) may be incomplete/missing.`
                    );
                  }

                  for (let i = 0; i < numElementsInListSlice; i++) {
                    const o = i * stride; // offset within this specific list's 'view'
                    // Check if read is within bounds of this slice's view
                    if (o + stride <= view.byteLength) {
                      arr.push(readViewValue(view, o, innerType));
                    } else {
                      // Should not be hit if numElementsInListSlice is correct
                      console.error(
                        `Internal error in List<${innerType}> parsing for column '${col.name}', row ${idx}. Attempting to read beyond slice bounds.`
                      );
                      break;
                    }
                  }
                  rows[idx][col.name] = arr;
                });
              }
              continue;
            }
            // List<Struct> (recursive)
            if (col.list_offsets_key && col.struct_fields) {
              const listOffsBlob = getBlob(col.list_offsets_key);
              if (!listOffsBlob || listOffsBlob.byteLength === 0) {
                console.warn(
                  `List<Struct> column '${col.name}' has empty or missing offsets blob. Assigning empty lists.`
                );
                for (let r = 0; r < num_rows; r++) rows[r][col.name] = [];
                continue;
              }
              const listOffs = decodeOffsets(listOffsBlob);

              if (
                listOffs.length === 0 ||
                listOffs[listOffs.length - 1] === 0
              ) {
                // All lists are empty
                for (let r = 0; r < num_rows; r++) rows[r][col.name] = [];
                continue;
              }

              // Parse every sub-field first (they behave just like top-level cols!)
              const subFrames = parseColumnarBuffer(dataBlobs, {
                num_rows: listOffs[listOffs.length - 1], // Total number of struct instances across all lists
                columns: col.struct_fields,
              });
              // Now gather per parent-row
              for (let r = 0; r < num_rows; r++) {
                // Iterate through parent rows
                rows[r][col.name] = []; // Initialize as an empty list
                if (r < listOffs.length - 1) {
                  // Ensure `r` is a valid index for listOffs
                  const startIdx = listOffs[r];
                  const endIdx = listOffs[r + 1];
                  for (let k = startIdx; k < endIdx; k++) {
                    if (k < subFrames.length) {
                      // Ensure subFrame index is valid
                      rows[r][col.name].push(subFrames[k]);
                    } else {
                      console.warn(
                        `List<Struct> column '${col.name}', parent row ${r}: struct index ${k} out of bounds for subFrames (length ${subFrames.length}).`
                      );
                    }
                  }
                } else if (r === listOffs.length - 1) {
                  // This implies num_rows is one greater than implied by listOffs.
                  // Or listOffs is empty, but this is handled above.
                  // This row has no corresponding offset entry, so it's an empty list.
                } else {
                  console.warn(
                    `List<Struct> column '${
                      col.name
                    }': parent row ${r} is beyond listOffs length (${
                      listOffs.length - 1
                    }). Assigning empty list.`
                  );
                }
              }
              continue;
            }
            // MsgPack fallback
            if (col.serialization_method === "msgpack_polars_list") {
              const blob = getBlob(col.data_key);
              if (!blob) {
                console.error(
                  `MsgPack fallback column '${col.name}' missing data_key '${col.data_key}'.`
                );
                for (let r = 0; r < num_rows; r++)
                  rows[r][col.name] = undefined;
                continue;
              }
              const decoded = decode(blob);
              if (!Array.isArray(decoded)) {
                console.error(
                  `MsgPack fallback column '${col.name}' did not decode to an array.`
                );
                for (let r = 0; r < num_rows; r++)
                  rows[r][col.name] = undefined;
                continue;
              }
              for (let r = 0; r < num_rows; r++) {
                rows[r][col.name] = r < decoded.length ? decoded[r] : undefined;
              }
              continue;
            }
            console.warn(
              `Column '${col.name}' uses unsupported layout or missing keys:`,
              JSON.stringify(col)
            );
            for (let r = 0; r < num_rows; r++) rows[r][col.name] = undefined; // Fill with undefined for unsupported
          }
          return rows;
        }

        // --- HELPER FUNCTIONS ---

        document
          .getElementById("show-unit-names-button")
          .addEventListener("click", () => {
            if (!lastParsedData || !decodedDefsMap) return;

            // Clone data to avoid mutating original
            const enriched = lastParsedData.map((row) => {
              let defId = row["unit_def_id"];
              if (defId === undefined && row["unit_def_id_bin"] !== undefined) {
                defId = row["unit_def_id_bin"];
              }
              const info = decodedDefsMap[defId?.toString?.()] || [];
              return {
                ...row,
                unit_def_name: info[0] || "",
                unit_pretty_name: info[1] || "",
              };
            });

            // Add columns for display (next to unit_def_id)
            let cols = lastColumns.slice();
            let idx = cols.findIndex((c) => c.name === "unit_def_id");
            if (idx === -1)
              idx = cols.findIndex((c) => c.name === "unit_def_id_bin");
            if (idx !== -1) {
              // Insert after unit_def_id
              cols = [
                ...cols.slice(0, idx + 1),
                { name: "unit_def_name" },
                { name: "unit_pretty_name" },
                ...cols.slice(idx + 1),
              ];
            } else {
              cols.push(
                { name: "unit_def_name" },
                { name: "unit_pretty_name" }
              );
            }

            parsedDataOutput.innerHTML = renderTable(enriched, cols);
          });
        function getTypedArrayConstructor(dtype) {
          const map = {
            Int8: Int8Array,
            UInt8: Uint8Array,
            Int16: Int16Array,
            UInt16: Uint16Array,
            Int32: Int32Array,
            UInt32: Uint32Array,
            Int64: BigInt64Array,
            UInt64: BigUint64Array,
            Float32: Float32Array,
            Float64: Float64Array,
            Boolean: Uint8Array,
          };
          const constructor = map[dtype];
          if (!constructor)
            throw new Error(`No TypedArray for dtype: ${dtype}`);
          return constructor;
        }

        function readValueFromView(dataView, offset, dtype) {
          // The 'true' argument specifies little-endian byte order, matching our Python struct.
          switch (dtype) {
            case "Int8":
              return [dataView.getInt8(offset), 1];
            case "UInt8":
              return [dataView.getUint8(offset), 1];
            case "Int16":
              return [dataView.getInt16(offset, true), 2];
            case "UInt16":
              return [dataView.getUint16(offset, true), 2];
            case "Int32":
              return [dataView.getInt32(offset, true), 4];
            case "UInt32":
              return [dataView.getUint32(offset, true), 4];
            case "Int64":
              return [dataView.getBigInt64(offset, true), 8];
            case "UInt64":
              return [dataView.getBigUint64(offset, true), 8];
            case "Float32":
              return [dataView.getFloat32(offset, true), 4];
            case "Float64":
              return [dataView.getFloat64(offset, true), 8];
            default:
              throw new Error(`Unsupported dtype for DataView: ${dtype}`);
          }
        }
        function jsonBigIntReplacer(key, value) {
          return typeof value === "bigint" ? value.toString() : value;
        }

        function renderTable(parsedData, columns) {
          if (!parsedData || parsedData.length === 0)
            return "<em>No data rows found.</em>";

          const headers = columns.map((col) => `<th>${col.name}</th>`).join("");

          /** prettify any cell value */
          const pretty = (val) => {
            if (val === null || val === undefined) return "";
            if (typeof val === "bigint") return val.toString(); // Handles top-level BigInts

            if (Array.isArray(val) || typeof val === "object") {
              // Use the replacer when stringifying objects/arrays that might contain BigInts
              return `<pre style="margin:0">${JSON.stringify(
                val,
                jsonBigIntReplacer,
                2
              )}</pre>`;
            }
            if (typeof val === "number" && !Number.isInteger(val))
              return val.toFixed(4);
            return val;
          };

          const rows = parsedData
            .slice(0, NUM_ROWS_TO_SHOW) // first 100 rows
            .map((row) => {
              const cells = columns
                .map((col) => `<td>${pretty(row[col.name])}</td>`)
                .join("");
              return `<tr>${cells}</tr>`;
            })
            .join("");

          const footer =
            parsedData.length > 100
              ? `<tr><td colspan="${columns.length}"><i>… and ${
                  parsedData.length - 100
                } more rows.</i></td></tr>`
              : "";

          return `<table><thead><tr>${headers}</tr></thead><tbody>${rows}${footer}</tbody></table>`;
        }

        function renderByteSizeBar(
          artifactData,
          totalUnpackedMsgPackSize,
          totalPackedSize
        ) {
          // Pass the whole artifact.data for static assets
          const schema = artifactData.schema;
          const data = artifactData.data; // Get the raw data blobs

          barContainer.innerHTML = "";
          let totalReportedStreamSize = 0;
          const streamEntries = [];

          for (const [streamName, streamInfo] of Object.entries(
            schema.streams
          )) {
            const streamSize = streamInfo.byte_size ?? 0; // Use 0 if undefined
            totalReportedStreamSize += streamSize;
            streamEntries.push({
              name: streamName,
              size: streamSize,
              type: "Stream",
            });
          }

          // --- Calculate sizes of other components ---
          let schemaSizeEstimate = 0;
          try {
            schemaSizeEstimate = new TextEncoder().encode(
              JSON.stringify(schema)
            ).length;
          } catch (e) {
            console.warn("Could not estimate schema size:", e);
          }
          streamEntries.push({
            name: "Schema Definition",
            size: schemaSizeEstimate,
            type: "Metadata",
          });

          let staticAssetsTotalSize = 0;
          if (schema.static_assets && data) {
            schema.static_assets.forEach((assetKey) => {
              if (data[assetKey] && data[assetKey] instanceof Uint8Array) {
                const assetSize = data[assetKey].byteLength;
                streamEntries.push({
                  name: `Static Asset: ${assetKey}`,
                  size: assetSize,
                  type: "Static Asset",
                });
                staticAssetsTotalSize += assetSize;
              } else if (data[assetKey]) {
                // If it's not a Uint8Array, it might have been pre-decoded by msgpack.
                // Try to stringify for a rough estimate.
                try {
                  const estimatedSize = new TextEncoder().encode(
                    JSON.stringify(data[assetKey])
                  ).length;
                  streamEntries.push({
                    name: `Static Asset (decoded): ${assetKey}`,
                    size: estimatedSize,
                    type: "Static Asset (est.)",
                  });
                  staticAssetsTotalSize += estimatedSize;
                } catch (e) {
                  streamEntries.push({
                    name: `Static Asset (unknown size): ${assetKey}`,
                    size: 0,
                    type: "Static Asset",
                  });
                }
              }
            });
          }

          const explicitlyAccountedSize = streamEntries
            .filter((e) => e.type !== "Overhead")
            .reduce((sum, entry) => sum + entry.size, 0);

          if (
            totalUnpackedMsgPackSize &&
            totalUnpackedMsgPackSize > explicitlyAccountedSize
          ) {
            const unaccountedSize =
              totalUnpackedMsgPackSize - explicitlyAccountedSize;
            if (unaccountedSize > 1) {
              // Only add if it's a significant positive contribution
              streamEntries.push({
                name: "Unaccounted/MsgPack Container",
                size: unaccountedSize,
                type: "Overhead",
              });
            }
          }

          const grandTotalSize = streamEntries.reduce(
            (sum, entry) => sum + entry.size,
            0
          );

          // Nice color palette
          const baseColorPalette = [
            "#2196f3", // blue 500
            "#4caf50", // green 500
            "#ff9800", // orange 500
            "#e91e63", // pink 500
            "#9c27b0", // purple 500
            "#00bcd4", // cyan 500
            "#ffc107", // amber 500
            "#f44336", // red 500
            "#3f51b5", // indigo 500
            "#009688", // teal 500
            "#2196f3", // Blue 500
            "#4caf50", // Green 500
            "#ff9800", // Orange 500
            "#e91e63", // Pink 500
            "#9c27b0", // Purple 500
            "#00bcd4", // Cyan 500
            "#ffc107", // Amber 500
            "#f44336", // Red 500
            "#3f51b5", // Indigo 500
            "#009688", // Teal 500
            "#8bc34a", // Light Green 500
            "#cddc39", // Lime 500
            "#ffeb3b", // Yellow 500
            "#ff5722", // Deep Orange 500
            "#795548", // Brown 500
            "#607d8b", // Blue Grey 500
          ];

          // Assign colors based on index to ensure variety for larger segments first
          const assignedColors = {};
          let colorIdx = 0;
          streamEntries.forEach((entry) => {
            if (entry.size > 0) {
              // Only assign colors to visible segments
              if (entry.type === "Overhead") {
                assignedColors[entry.name] = "#9e9e9e"; // Specific grey for overhead
              } else if (entry.type === "Metadata") {
                assignedColors[entry.name] = "#673ab7"; // Deep Purple for Schema (distinct)
              } else {
                assignedColors[entry.name] =
                  baseColorPalette[colorIdx % baseColorPalette.length];
                colorIdx++;
              }
            }
          });

          barContainer.innerHTML = ""; // Clear previous bar

          streamEntries.forEach((entry) => {
            if (entry.size === 0) return;

            // const widthPercent = (entry.size / grandTotalSize) * 100; // Not strictly needed if using flex-grow

            const segment = document.createElement("div");
            segment.style.flex = `${entry.size} 0 auto`; // Use actual size for flex basis
            segment.style.backgroundColor =
              assignedColors[entry.name] || "#cccccc"; // Fallback color
            segment.style.minWidth = "3px"; // Ensure very small segments are still visible
            // segment.style.height = "100%"; // Ensure it fills the container height

            segment.addEventListener("mouseenter", (e) => {
              const percentOfTotal = (
                (entry.size / totalUnpackedMsgPackSize) *
                100
              ).toFixed(1);
              tooltip.style.opacity = "1";
              tooltip.textContent = `${entry.type}: ${
                entry.name
              } - ${formatBytes(entry.size)}/${formatBytes(
                totalUnpackedMsgPackSize
              )} (${percentOfTotal}%)`;
            });
            segment.addEventListener("mousemove", (e) => {
              tooltip.style.top = `${e.clientY + 10}px`;
              tooltip.style.left = `${e.clientX + 10}px`;
            });
            segment.addEventListener("mouseleave", () => {
              tooltip.style.opacity = "0";
            });

            barContainer.appendChild(segment);
          });

          // --- DETAILED TEXT BREAKDOWN (SORTED) ---
          // Sort ALL entries (including potentially negative discrepancy) by absolute size for the text list
          const sortedTextEntries = [...streamEntries].sort(
            (a, b) => Math.abs(b.size) - Math.abs(a.size)
          );
          let breakdownText = `Total Packed Zstd Size: ${formatBytes(
            totalPackedSize
          )}\n`;
          breakdownText += `Total Unpacked MessagePack Size (from Zstd): ${formatBytes(
            totalUnpackedMsgPackSize
          )}\n`;
          breakdownText += `Sum of Accounted Parts (before discrepancy): ${formatBytes(
            explicitlyAccountedSize
          )}\n`;
          if (streamEntries.find((e) => e.type === "Overhead/Discrepancy")) {
            breakdownText += `Calculated Discrepancy/Container: ${formatBytes(
              discrepancy
            )}\n`;
          }
          breakdownText += `(Sum of positive parts shown in bar: ${formatBytes(
            grandTotalSize
          )})\n\n`;
          breakdownText += "Breakdown (Sorted by size, largest first):\n";
          breakdownText += "-------------------------------------------\n";

          sortedTextEntries.forEach((entry) => {
            // Skip zero-size entries unless it's the discrepancy entry and it's non-zero
            if (entry.size === 0 && entry.type !== "Overhead/Discrepancy")
              return;
            if (entry.type === "Overhead/Discrepancy" && entry.size === 0)
              return;

            const percentOfTotalMsgPack = (
              (entry.size / totalUnpackedMsgPackSize) *
              100
            ).toFixed(1);
            let displayName = entry.name;
            if (entry.type === "Stream") displayName = `Stream: ${displayName}`;
            else if (
              entry.type === "Static Asset" ||
              entry.type === "Static Asset (est.)"
            )
              displayName = `Asset: ${displayName}`;
            // Metadata and Overhead/Discrepancy names are already descriptive.

            breakdownText += `- ${displayName}\n`;
            breakdownText += `  Type: ${entry.type}, Size: ${formatBytes(
              entry.size
            )} (${percentOfTotalMsgPack}% of total unpacked)\n`;
          });

          if (detailedBreakdownOutput) {
            detailedBreakdownOutput.textContent = breakdownText;
          } else {
            console.warn("#detailed-breakdown-output element not found.");
          }
        }

        // Utility to make consistent pastel color from string (stream name)
        function stringToColor(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++)
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
          const h = hash % 360;
          return `hsl(${h}, 70%, 75%)`;
        }

        function formatBytes(bytes) {
          if (bytes < 1024) return `${bytes} B`;
          if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
          return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
        }
      });

      /** read UInt32 little-endian offsets into a JS array */
      function decodeOffsets(u8) {
        const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
        const out = [];
        for (let i = 0; i < u8.byteLength; i += 4) {
          out.push(dv.getUint32(i, true));
        }
        return out;
      }

      /** slice a payload Uint8Array using an offsets array */
      function sliceByOffsets(payload, offsets) {
        const rows = [];
        for (let i = 0; i < offsets.length - 1; i++) {
          const start = offsets[i],
            end = offsets[i + 1];
          rows.push(payload.slice(start, end));
        }
        return rows;
      }


      function getStride(dtype) {
        switch (dtype) {
          case "Int8":
          case "UInt8":
          case "Boolean":
            return 1;
          case "Int16":
          case "UInt16":
            return 2;
          case "Int32":
          case "UInt32":
          case "Float32":
            return 4;
          case "Int64":
          case "UInt64":
          case "Float64":
            return 8;
          default:
            throw new Error(`Unknown dtype for stride: ${dtype}`);
        }
      }


      function readViewValue(view, offset, dtype) {
        switch (dtype) {
          case "Int8":
            return view.getInt8(offset);
          case "UInt8":
            return view.getUint8(offset);
          case "Boolean":
            return !!view.getUint8(offset);
          case "Int16":
            return view.getInt16(offset, true);
          case "UInt16":
            return view.getUint16(offset, true);
          case "Int32":
            return view.getInt32(offset, true);
          case "UInt32":
            return view.getUint32(offset, true);
          case "Float32":
            return view.getFloat32(offset, true);
          case "Int64":
            return view.getBigInt64(offset, true);
          case "UInt64":
            return view.getBigUint64(offset, true);
          case "Float64":
            return view.getFloat64(offset, true);
          default:
            throw new Error(`Unknown dtype for DataView: ${dtype}`);
        }
      }


      function debugCheckForIncompleteColumns(rows, columns) {
        console.group("Column Completeness Debug");
        columns.forEach((col) => {
          let undefinedCount = 0;
          for (let i = 0; i < rows.length; i++) {
            if (rows[i][col.name] === undefined || rows[i][col.name] === null) {
              undefinedCount++;
            }
          }
          if (undefinedCount > 0) {
            console.warn(
              `Column "${col.name}" has ${undefinedCount} undefined/null values out of ${rows.length} rows`
            );
          } else {
            console.log(`Column "${col.name}" fully populated.`);
          }
        });
        console.groupEnd();
      }


      function initLogBinsButton(artifact) {
        const logBinsButton = document.getElementById("log-bins-button");
        if (!logBinsButton) {
          console.warn("Log Bins button not found.");
          return;
        }
        logBinsButton.disabled = false;
        logBinsButton.addEventListener("click", () => {
          if (!artifact || !artifact.data) {
            console.warn("No artifact loaded.");
            return;
          }
          console.group("=== Bundle Structure & Actual Bin Sizes ===");
          Object.entries(artifact.data).forEach(([key, val]) => {
            if (val instanceof Uint8Array) {
              console.log(`TOP '${key}': Uint8Array (${val.byteLength} bytes)`);
            } else if (typeof val === "object" && val !== null) {
              const keys = Object.keys(val);
              console.log(`TOP '${key}': object (${keys.length} sub-keys)`);
              keys.forEach((sub) => {
                const subVal = val[sub];
                if (subVal instanceof Uint8Array) {
                  console.log(
                    `   ↳ ${sub} → Uint8Array (${subVal.byteLength} bytes)`
                  );
                } else {
                  console.log(`   ↳ ${sub} → ${typeof subVal}`);
                }
              });
            } else {
              console.log(`TOP '${key}':`, typeof val);
            }
          });
          console.groupEnd();
        });
      }


      function generateChart(data) {
        const dimensionCol = document.getElementById("viz-dimension").value;
        const metricCol = document.getElementById("viz-metric").value;
        const groupCol = document.getElementById("viz-group").value;
        const sandboxChartEl = document.getElementById("sandbox-chart");

        if (!dimensionCol || !metricCol) {
          alert("Please select a Dimension and a Metric.");
          return;
        }

        const currentTheme =
          document.documentElement.getAttribute("data-theme") || "light";
        if (sandboxChartInstance) sandboxChartInstance.dispose();
        sandboxChartInstance = echarts.init(sandboxChartEl, currentTheme);

        // AGGREGATE DATA
        const aggregated = new Map();
        data.forEach((row) => {
          const dimKey = row[dimensionCol];
          const groupKey = groupCol ? row[groupCol] : "default";
          const metricValue = Number(row[metricCol] || 0);

          const key = `${dimKey}|${groupKey}`;
          if (!aggregated.has(key)) {
            aggregated.set(key, { dim: dimKey, group: groupKey, metric: 0 });
          }
          aggregated.get(key).metric += metricValue;
        });

        const chartData = Array.from(aggregated.values());

        // ** THE FIX IS HERE **
        // We now use `lastColumns` which is available everywhere.
        const isTimeSeries = lastColumns
          .find((c) => c.name === dimensionCol)
          .dtype.includes("Int");

        if (groupCol) {
          // GROUPED CHART
          const seriesData = new Map();
          chartData.forEach((d) => {
            if (!seriesData.has(d.group)) seriesData.set(d.group, []);
            seriesData.get(d.group).push({ value: [d.dim, d.metric] });
          });

          // BigInt-safe sorting for the x-axis categories
          const dimensions = [...new Set(chartData.map((d) => d.dim))].sort(
            (a, b) => {
              if (a < b) return -1;
              if (a > b) return 1;
              return 0;
            }
          );

          const series = Array.from(seriesData.entries()).map(
            ([groupName, dataPoints]) => ({
              name: String(groupName), // Ensure group name is a string for the legend
              type: isTimeSeries ? "line" : "bar",
              stack: isTimeSeries ? null : "total",
              smooth: true,
              data: dimensions.map((dim) => {
                const point = dataPoints.find((p) => p.value[0] === dim);
                return point ? point.value[1] : 0;
              }),
            })
          );

          sandboxChartInstance.setOption({
            tooltip: { trigger: "axis" },
            legend: {
              type: "scroll",
              data: Array.from(seriesData.keys()).map(String),
            },
            xAxis: { type: "category", data: dimensions.map(String) }, // Ensure axis labels are strings
            yAxis: { type: "value" },
            series: series,
          });
        } else {
          // SINGLE SERIES CHART
          // BigInt-safe sorting
          chartData.sort((a, b) => {
            if (a.dim < b.dim) return -1;
            if (a.dim > b.dim) return 1;
            return 0;
          });

          sandboxChartInstance.setOption({
            tooltip: { trigger: "axis" },
            xAxis: {
              type: "category",
              data: chartData.map((d) => String(d.dim)),
            },
            yAxis: { type: "value" },
            series: [
              {
                data: chartData.map((d) => d.metric),
                type: isTimeSeries ? "line" : "bar",
                smooth: true,
              },
            ],
          });
        }
      }
      

      function setupSandbox(columns, data) {
        const sandbox = document.getElementById("visualization-sandbox");
        const btnContainer = document.getElementById("viz-buttons-container");
        const controlsContainer = document.getElementById("sandbox-controls");
        const sandboxChartEl = document.getElementById("sandbox-chart");

        btnContainer.innerHTML = "";
        controlsContainer.innerHTML = ""; // Clear old controls
        if (sandboxChartInstance) {
          sandboxChartInstance.dispose();
          sandboxChartInstance = null;
        }
        if (!data || data.length === 0) {
          sandbox.classList.add("hidden");
          return;
        }

        const currentTheme =
          document.documentElement.getAttribute("data-theme") || "light";
        sandboxChartInstance = echarts.init(sandboxChartEl, currentTheme);

        VIZ_REGISTRY.forEach((viz) => {
          if (viz.check(columns)) {
            const btn = document.createElement("button");
            btn.textContent = viz.name;
            btn.onclick = () => {
              viz.render(data, sandboxChartInstance, controlsContainer);
            };
            btnContainer.appendChild(btn);
          }
        });

        if (btnContainer.children.length > 0) {
          sandbox.classList.remove("hidden");
          // Automatically click the first available visualization button for a good default.
          btnContainer.children[0].click();
        } else {
          sandbox.classList.add("hidden");
        }
      }
      

      document.addEventListener("DOMContentLoaded", () => {
        const accordions = document.querySelectorAll(".accordion");
        const toggleAllButton = document.getElementById("toggle-all-button");
        let hasExpandedOnce = false;

        // Initialize any pre-marked active accordions
        accordions.forEach((acc) => {
            console.log(acc)
          const panel = acc.parentElement.querySelector('.panel');
          if (acc.classList.contains("active")) {
            //   panel.style.maxHeight = panel.scrollHeight + "px";
            panel.style.maxHeight = 500 + "px";
          }
        });

        // Individual toggle
        accordions.forEach((acc) => {
          acc.addEventListener("click", function () {
            hasExpandedOnce = true;
            this.classList.toggle("active");
          const panel = acc.parentElement.querySelector('.panel');
            if (panel.style.maxHeight) {
              panel.style.maxHeight = null;
            } else {
              //   panel.style.maxHeight = panel.scrollHeight + "px";
              panel.style.maxHeight = 500 + "px";
              panel.style.overflowY = "auto";
            }
          });
        });

        // Global toggle (same as before)
        toggleAllButton.addEventListener("click", () => {
          const anyOpen = Array.from(accordions).some((acc) =>
            acc.classList.contains("active")
          );
          if (anyOpen) {
            accordions.forEach((acc) => {
              acc.classList.remove("active");
          const panel = acc.parentElement.querySelector('.panel');
              panel.style.maxHeight = null;
              panel.style.overflowY = "auto";
            });
            toggleAllButton.textContent = "Expand All";
          } else {
            accordions.forEach((acc) => {
              acc.classList.add("active");
          const panel = acc.parentElement.querySelector('.panel');
              //   panel.style.maxHeight = panel.scrollHeight + "px";
              panel.style.maxHeight = 500 + "px";
              panel.style.overflowY = "auto";
            });
            toggleAllButton.textContent = "Collapse All";
          }
        });

        // animate expand on accordion on hover
        document.querySelectorAll(".panel").forEach((panel) => {
          panel.addEventListener("mouseenter", () => {
            const accordion = panel.parentElement.querySelector('.accordion');
            if (
              !hasExpandedOnce &&
              accordion &&
              accordion.classList.contains("accordion") &&
              !accordion.classList.contains("active")
            ) {
              accordion.classList.add("animate");
            }
          });
          panel.addEventListener("mouseleave", () => {
            const accordion = panel.parentElement.querySelector('.accordion');
            if (accordion && accordion.classList.contains("accordion")) {
              accordion.classList.remove("animate");
            }
          });
        });
      });


      function processDataInChunksAsync(data, chunkProcessor, initialAccumulator, chunkSize = 2000) {
        return new Promise((resolve) => {
            let i = 0;
            const totalRows = data.length;
            let accumulator = initialAccumulator;

            function runNextChunk() {
                if (i >= totalRows) {
                    resolve(accumulator);
                    return;
                }

                const chunkEnd = Math.min(i + chunkSize, totalRows);
                const chunk = data.slice(i, chunkEnd);

                // Run the user-provided logic on the small chunk
                accumulator = chunkProcessor(chunk, accumulator);

                i = chunkEnd;

                // Yield to the main thread, allowing UI updates (like closing the tab),
                // then queue the next chunk of work.
                setTimeout(runNextChunk, 0);
            }

            // Start the process
            runNextChunk();
        });
    }

    </script>
    <script type="module">
      const html = document.documentElement;
      const toggle = document.getElementById("theme-toggle");

      // Determine initial theme
      const saved =
        localStorage.getItem("theme") ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light");
      html.setAttribute("data-theme", saved);

      // Update button label based on current theme
      function updateToggleText() {
        const isDark = html.getAttribute("data-theme") === "dark";
        toggle.textContent = isDark ? "Light Mode" : "Dark Mode";
      }
      updateToggleText();

      toggle.addEventListener("click", () => {
        // Flip theme
        const next =
          html.getAttribute("data-theme") === "dark" ? "light" : "dark";
        html.setAttribute("data-theme", next);
        localStorage.setItem("theme", next);
        updateToggleText();
      });

      //    View mode
      const viewModeToggle = document.getElementById("view-mode-toggle");

      const savedViewMode = localStorage.getItem("viewMode") || "Comfort";
      html.setAttribute("data-viewmode", savedViewMode);

      function updateViewModeToggle() {
        viewModeToggle.textContent =
          html.getAttribute("data-viewmode") === "comfort"
            ? "Detailed"
            : "Comfort";
      }
      updateViewModeToggle();

      viewModeToggle.addEventListener("click", () => {
        // Flip theme
        const next =
          html.getAttribute("data-viewmode") === "comfort"
            ? "detailed"
            : "comfort";
        html.setAttribute("data-viewmode", next);
        localStorage.setItem("viewMode", next);
        updateViewModeToggle();
      });
    </script>
  </body>
</html>
