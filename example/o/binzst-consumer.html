<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZST Artifact Consumer (Modern ESM)</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        line-height: 1.6;
        margin: 0;
        background-color: #f8f9fa;
        color: #212529;
      }
      .container {
        max-width: 900px;
        margin: 2rem auto;
        padding: 2rem;
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      h1,
      h2 {
        color: #343a40;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 0.5rem;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }
      label {
        font-weight: bold;
      }
      select,
      button {
        padding: 0.5rem 1rem;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 1rem;
        cursor: pointer;
      }
      button {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #0056b3;
      }
      #status {
        font-style: italic;
        color: #6c757d;
        margin-bottom: 1rem;
        white-space: pre-line;
      }
      pre {
        background-color: #e9ecef;
        padding: 1rem;
        border-radius: 4px;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 500px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>High-Performance Artifact Viewer</h1>

      <div class="controls">
        <label for="stream-select">Select Data Stream:</label>
        <select id="stream-select" disabled></select>
        <button id="load-button" disabled>Load and Parse Data</button>
      </div>

      <div id="status">Loading schema...</div>

      <h2>Parsed Data:</h2>
      <pre id="output">No data loaded yet.</pre>
    </div>

    <!-- The script tag now specifies it is a module, enabling modern import/export syntax -->

    <script type="module">
      import { Zstd } from "https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2.23.0/dist/index.js";

      document.addEventListener("DOMContentLoaded", async () => {
        // ---- ASYNC INIT: Zstd ----
        const zstd = await Zstd.load();

        const streamSelect = document.getElementById("stream-select");
        const loadButton = document.getElementById("load-button");
        const statusDiv = document.getElementById("status");
        const outputPre = document.getElementById("output");

        const REPLAY_ID = "test_replay_id";
        const BASE_PATH = `./${REPLAY_ID}/`;
        let schema = null;

        // --- Step 1: Load the master schema on page load ---
        try {
          const response = await fetch(`${BASE_PATH}schema.json`);
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          schema = await response.json();

          const streamNames = Object.keys(schema.streams);
          if (streamNames.length === 0) {
            throw new Error(
              "Schema loaded, but the 'streams' object is empty. Check the Python script output."
            );
          }

          streamNames.forEach((name) => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            streamSelect.appendChild(option);
          });

          streamSelect.disabled = false;
          loadButton.disabled = false;
          statusDiv.textContent =
            'Schema loaded. Select a stream and click "Load".';
        } catch (error) {
          statusDiv.textContent = `Error loading schema: ${error.message}`;
          console.error("Schema fetch error:", error);
          return;
        }

        function renderTable(parsedData, columns) {
          if (!parsedData.length) return "<em>No data.</em>";
          const headers = columns.map((col) => `<th>${col.name}</th>`).join("");
          const rows = parsedData
            .map(
              (row) =>
                "<tr>" +
                columns.map((col) => `<td>${row[col.name]}</td>`).join("") +
                "</tr>"
            )
            .join("\n");
          return `<table>
                    <thead><tr>${headers}</tr></thead>
                    <tbody>${rows}</tbody>
                </table>`;
        }

        // --- Step 2: Set up the main data loading logic ---
        loadButton.addEventListener("click", async () => {
          const selectedStreamName = streamSelect.value;
          if (!selectedStreamName) return;

          outputPre.textContent = "";
          statusDiv.textContent = `Loading stream: ${selectedStreamName}...`;

          try {
            const streamInfo = schema.streams[selectedStreamName];
            if (!streamInfo)
              throw new Error(
                `Stream '${selectedStreamName}' not found in schema.`
              );

            // --- Step 2a: Fetch and decompress the binary file ---
            statusDiv.textContent += "\nFetching binary file...";
            const binaryResponse = await fetch(
              `${BASE_PATH}${streamInfo.file}`
            );
            if (!binaryResponse.ok)
              throw new Error(`HTTP error! status: ${binaryResponse.status}`);

            const compressedBuffer = await binaryResponse.arrayBuffer();
            statusDiv.textContent += `\nDecompressing ${compressedBuffer.byteLength} bytes...`;

            const decompressedBytes = zstd.decompress(
              new Uint8Array(compressedBuffer)
            );
            const arrayBuffer = decompressedBytes.buffer;
            statusDiv.textContent += `\nDecompressed to ${arrayBuffer.byteLength} bytes. Parsing...`;

            // --- Step 2b: Parse the buffer using the schema contract ---
            const parsedData = parseRowMajorBuffer(arrayBuffer, streamInfo);

            // outputPre.textContent = JSON.stringify(parsedData, (key, value) =>
            //     typeof value === 'bigint' ? value.toString() : value, 2);

            outputPre.innerHTML = renderTable(parsedData, streamInfo.columns);

            statusDiv.textContent = `Successfully parsed ${parsedData.length} rows from '${selectedStreamName}'.`;
          } catch (error) {
            statusDiv.textContent = `Error processing stream: ${error.message}`;
            console.error("Processing error:", error);
          }
        });
      });

      // --- Step 3: The Core Parsing Function ---
      function parseRowMajorBuffer(arrayBuffer, streamInfo) {
        const dataView = new DataView(arrayBuffer);
        const results = [];
        const { num_rows, row_byte_stride, columns } = streamInfo;

        for (let i = 0; i < num_rows; i++) {
          const rowStartOffset = i * row_byte_stride;
          const rowObject = {};
          let currentOffsetInRow = 0;

          // Iterate through the columns IN THE ORDER defined by the schema
          for (const column of columns) {
            // Read the raw value from the buffer based on its dtype
            const [rawValue, bytesRead] = readValueFromView(
              dataView,
              rowStartOffset + currentOffsetInRow,
              column.dtype
            );

            // Apply any transformations (like de-quantization)
            let finalValue = rawValue;
            if (column.transform && column.transform.scale) {
              // JS BigInts don't mix with Numbers, so handle them separately
              if (typeof finalValue === "bigint") {
                finalValue = Number(finalValue) * column.transform.scale;
              } else {
                finalValue = finalValue * column.transform.scale;
              }
            }

            rowObject[column.name] = finalValue;
            currentOffsetInRow += bytesRead;
          }
          results.push(rowObject);
        }
        return results;
      }

      function readValueFromView(dataView, offset, dtype) {
        // Little-endian is assumed (true), matching our Python struct format '<'
        switch (dtype) {
          case "Int8":
            return [dataView.getInt8(offset), 1];
          case "UInt8":
            return [dataView.getUint8(offset), 1];
          case "Int16":
            return [dataView.getInt16(offset, true), 2];
          case "UInt16":
            return [dataView.getUint16(offset, true), 2];
          case "Int32":
            return [dataView.getInt32(offset, true), 4];
          case "UInt32":
            return [dataView.getUint32(offset, true), 4];
          case "Int64":
            return [dataView.getBigInt64(offset, true), 8];
          case "UInt64":
            return [dataView.getBigInt64(offset, true), 8]; // No Uint64 in JS DataView, use BigInt
          case "Float32":
            return [dataView.getFloat32(offset, true), 4];
          case "Float64":
            return [dataView.getFloat64(offset, true), 8];
          default:
            throw new Error(`Unsupported dtype in schema: ${dtype}`);
        }
      }
    </script>
  </body>
</html>
